" enable syntax highlighting
syntax on
"colorscheme slate
"colorscheme murphy "The bright one I had for ages
colorscheme elflord
"colorscheme seashell
"colorscheme zenburn
"colorscheme coffee
" define `Ispell' language and personal dictionary, used in several places
" below:
let IspellLang = 'british'
let PersonalDict = '~/.ispell_' . IspellLang


" show cursor line and column in the status line
set ruler
set showcmd
set statusline=%-10t%m%r%h%w\ [%2p%%\ %4L\L]\ %<%F


" screen scrolls when you get to 6 lines from the window edge rather than having to go all the way to the top or bottom
set so=6
set tabstop=2
set shiftwidth=2               " number of spaces used for (auto)indenting
set smarttab                   " a <tab> in an indent insets 'shiftwidth' spaces (not tabstop)
set gdefault                  " assume the /g flag on :s substitutions to replace all matches in a line:
set showmatch                  " show matching brackets
set showmode                   " display mode INSERT/REPLACE/...
set esckeys                    " Required to be able to use keypad keys and map missed escape sequences
set backspace=indent,eol,start " allow backspacing over everything in insert mode 
set vb t_vb=                   " turn off bell
set history=500                " store last 500 cmds
"set mouse=a                    " Turn mouse on
"set mousef                     " focus follows mouse
set textwidth=100             " Set the width of the text
set winminheight=0             "these settings allow windows to minimise when moving between horizontal panes
set nocompatible               " Switch it off if you prefer real vi compatibility
set ignorecase                 " make searches case-insensitive, unless they contain upper-case letters:
set smartcase
set incsearch                  " show the `best match so far' as search strings are typed:
set hlsearch                   " highlight search terms

" Stuff for italia use save with W to copy up to the box 1st is from 2nd is too
" Change the working directories for my box and for the itdevapp01 box (get to
" via orbistbs)
 "command! W w | silent execute "!(rsync_itdevapp01_development /shared/home/odavies/cvs_src/Lbr_Italia_OXi/ B_LBRIT_RT2286_Italian_Poker_Phase_2/dev/ >& /dev/null; dcop knotify default notify eventname rsync_itdevapp01 'Finished.' '' '' 16 0) &" | redraw!
command! W w | echo "disabled"

" Complete longest common string, then each full match
" Enable this for bash compatible behaviour
" set wildmode=longest,full

" Try to get the correct main terminal type
if &term =~ "xterm"
    let myterm = "xterm"
else
    let myterm =  &term
endif
let myterm = substitute(myterm, "cons[0-9][0-9].*$",  "linux", "")
let myterm = substitute(myterm, "vt1[0-9][0-9].*$",   "vt100", "")
let myterm = substitute(myterm, "vt2[0-9][0-9].*$",   "vt220", "")
let myterm = substitute(myterm, "\\([^-]*\\)[_-].*$", "\\1",   "")

" treat lines starting with a quote mark as comments (for `Vim' files, such as
" this very one!), and colons as well so that reformatting usenet messages from
" `Tin' users works OK:
set comments+=b:\"
set comments+=n::
set comments+=fb:*
" Here we define the keys of the NumLock in keyboard transmit mode of xterm
" which misses or hasn't activated Alt/NumLock Modifiers.  Often not defined
" within termcap/terminfo and we should map the character printed on the keys.
if myterm == "xterm" || myterm == "kvt" || myterm == "gnome"
    " keys in insert/command mode.
    map! <ESC>Oo  :
    map! <ESC>Oj  *
    map! <ESC>Om  -
    map! <ESC>Ok  +
    map! <ESC>Ol  ,
    map! <ESC>OM  
    map! <ESC>Ow  7
    map! <ESC>Ox  8
    map! <ESC>Oy  9
    map! <ESC>Ot  4
    map! <ESC>Ou  5
    map! <ESC>Ov  6
    map! <ESC>Oq  1
    map! <ESC>Or  2
    map! <ESC>Os  3
    map! <ESC>Op  0
    map! <ESC>On  .
    " keys in normal mode
    map <ESC>Oo  :
    map <ESC>Oj  *
    map <ESC>Om  -
    map <ESC>Ok  +
    map <ESC>Ol  ,
    map <ESC>OM  
    map <ESC>Ow  7
    map <ESC>Ox  8
    map <ESC>Oy  9
    map <ESC>Ot  4
    map <ESC>Ou  5
    map <ESC>Ov  6
    map <ESC>Oq  1
    map <ESC>Or  2
    map <ESC>Os  3
    map <ESC>Op  0
    map <ESC>On  .
endif

" xterm but without activated keyboard transmit mode
" and therefore not defined in termcap/terminfo.
if myterm == "xterm" || myterm == "kvt" || myterm == "gnome"
    " keys in insert/command mode.
    map! <Esc>[H  <Home>
    map! <Esc>[F  <End>
    " Home/End: older xterms do not fit termcap/terminfo.
    map! <Esc>[1~ <Home>
    map! <Esc>[4~ <End>
    " Up/Down/Right/Left
    map! <Esc>[A  <Up>
    map! <Esc>[B  <Down>
    map! <Esc>[C  <Right>
    map! <Esc>[D  <Left>
    " KP_5 (NumLock off)
    map! <Esc>[E  <Insert>
    " PageUp/PageDown
    map <ESC>[5~ <PageUp>
    map <ESC>[6~ <PageDown>
    map <ESC>[5;2~ <PageUp>
    map <ESC>[6;2~ <PageDown>
    map <ESC>[5;5~ <PageUp>
    map <ESC>[6;5~ <PageDown>
    " keys in normal mode
    map <ESC>[H  0
    map <ESC>[F  $
    " Home/End: older xterms do not fit termcap/terminfo.
    map <ESC>[1~ 0
    map <ESC>[4~ $
    " Up/Down/Right/Left
    map <ESC>[A  k
    map <ESC>[B  j
    map <ESC>[C  l
    map <ESC>[D  h
    " KP_5 (NumLock off)
    map <ESC>[E  i
    " PageUp/PageDown
    map <ESC>[5~ 
    map <ESC>[6~ 
    map <ESC>[5;2~ 
    map <ESC>[6;2~ 
    map <ESC>[5;5~ 
    map <ESC>[6;5~ 
endif

" xterm/kvt but with activated keyboard transmit mode.
" Sometimes not or wrong defined within termcap/terminfo.
if myterm == "xterm" || myterm == "kvt" || myterm == "gnome"
    " keys in insert/command mode.
    map! <Esc>OH <Home>
    map! <Esc>OF <End>
    map! <ESC>O2H <Home>
    map! <ESC>O2F <End>
    map! <ESC>O5H <Home>
    map! <ESC>O5F <End>
    " Cursor keys which works mostly
    " map! <Esc>OA <Up>
    " map! <Esc>OB <Down>
    " map! <Esc>OC <Right>
    " map! <Esc>OD <Left>
    map! <Esc>[2;2~ <Insert>
    map! <Esc>[3;2~ <Delete>
    map! <Esc>[2;5~ <Insert>
    map! <Esc>[3;5~ <Delete>
    map! <Esc>O2A <PageUp>
    map! <Esc>O2B <PageDown>
    map! <Esc>O2C <S-Right>
    map! <Esc>O2D <S-Left>
    map! <Esc>O5A <PageUp>
    map! <Esc>O5B <PageDown>
    map! <Esc>O5C <S-Right>
    map! <Esc>O5D <S-Left>
    " KP_5 (NumLock off)
    map! <Esc>OE <Insert>
    " keys in normal mode
    map <ESC>OH  0
    map <ESC>OF  $
    map <ESC>O2H  0
    map <ESC>O2F  $
    map <ESC>O5H  0
    map <ESC>O5F  $
    " Cursor keys which works mostly
    " map <ESC>OA  k
    " map <ESC>OB  j
    " map <ESC>OD  h
    " map <ESC>OC  l
    map <Esc>[2;2~ i
    map <Esc>[3;2~ x
    map <Esc>[2;5~ i
    map <Esc>[3;5~ x
    map <ESC>O2A  ^B
    map <ESC>O2B  ^F
    map <ESC>O2D  b
    map <ESC>O2C  w
    map <ESC>O5A  ^B
    map <ESC>O5B  ^F
    map <ESC>O5D  b
    map <ESC>O5C  w
    " KP_5 (NumLock off)
    map <ESC>OE  i
endif

if myterm == "linux"
    " keys in insert/command mode.
    map! <Esc>[G  <Insert>
    " KP_5 (NumLock off)
    " keys in normal mode
    " KP_5 (NumLock off)
    map <ESC>[G  i
endif

" This escape sequence is the well known ANSI sequence for
" Remove Character Under The Cursor (RCUTC[tm])
map! <Esc>[3~ <Delete>
map  <ESC>[3~    x

" Only do this part when compiled with support for autocommands. 
if has("autocmd") 
  " When editing a file, always jump to the last known cursor position. 
  " Don't do it when the position is invalid or when inside an event handler 
  " (happens when dropping a file on gvim). 
  autocmd BufReadPost * 
    \ if line("'\"") > 0 && line("'\"") <= line("$") | 
    \   exe "normal g`\"" | 
    \ endif 
 
endif " has("autocmd")

" Changed default required by SuSE security team--be aware if enabling this
" that it potentially can open for malicious users to do harmful things.
set modelines=0


"custom copy'n'paste
"copy the current visual selection to ~/.vbuf
vmap y :w! ~/.vbuf<CR>
"copy the current line to the buffer file if no visual selection
" nmap y :.w! ~/.vbuf<CR>
"paste the contents of the buffer file
nmap p :r ~/.vbuf<CR>
" Comment out code
nmap c :TC<CR>
vmap c :TC<CR>
command! CD cd %:p:h
command! VC !viewcvs %

" ctrl+D and T add tab to start of highlighted area
vnoremap <C-T> >
vnoremap <C-D> <LT>
vmap <Tab> <C-T>
vmap <S-Tab> <C-D>

" shift+Y yanks to end of line 
noremap Y y$

" ctrl-n or p go through stack
nmap <C-n> :cn<cr>

" Map turning line numbers on or off
:map <F3> :set nonumber<CR>
:map <F2> :set number<CR>
" Map list on/off
:map <F4> :set list<CR>
:map <F5> :set nolist<CR>

" session handling
map <F6> :mksession! ~/.vim/.
map <F7> :source ~/.vim/.

" tab handling
map <F8> :tabf
map <F9> :tabnew
" alt p n
map n  :tabp<CR>
map m  :tabn<CR>

" formatting info on/off quickly
map <F12> :set number! list!<CR>

" make tabs/space marks stick out
map <S-F12> :hi SpecialKey ctermfg=Red<CR>

"make the backspace work better
"map <Del> <BS>
"imap <Del> <BS>

" highlight tabs and trailing spaces
set listchars=tab:>\ ,trail:.
set list

" ob_log::write with Ctrl-L
inoremap <C-l> ob_log::write 

nmap <C-p> :cp<cr>
" Collapse to end of loop etc
function ToggleFold()
   if foldlevel('.') == 0
      " No fold exists at the current line,
      " so create a fold based on indentation

      let l_min = line('.')   " the current line number
      let l_max = line('$')   " the last line number
      let i_min = indent('.') " the indentation of the current line
      let l = l_min + 1

      " Search downward for the last line whose indentation > i_min
      while l <= l_max
         " if this line is not blank ...
         if strlen(getline(l)) > 0 && getline(l) !~ '^\s*$'
            if indent(l) <= i_min
               " we've gone too far
               let l = l - 1    " backtrack one line
               break
            endif
         endif
         let l = l + 1
      endwhile

      " Clamp l to the last line
      if l > l_max
         let l = l_max
      endif

      " Backtrack to the last non-blank line
      while l > l_min
         if strlen(getline(l)) > 0 && getline(l) !~ '^\s*$'
            break
         endif
         let l = l - 1
      endwhile

      "execute "normal i" . l_min . "," . l . " fold"   " print debug info

      if l > l_min
         " Create the fold from l_min to l
         execute l_min . "," . l . " fold"
      endif
   else
      " Delete the fold on the current line
      normal zd
   endif
endfunction

nmap <space> :call ToggleFold()<CR>
" get easier to use and more user friendly vim defaults
" /etc/vimrc ends here
